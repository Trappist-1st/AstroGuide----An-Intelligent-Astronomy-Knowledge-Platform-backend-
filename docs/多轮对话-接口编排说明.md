# 多轮对话：接口编排说明

当前后端已支持「同一会话内多轮对话」：同一 `conversationId` 下多次「用户发问 → AI 流式回答」，且 AI 能带上历史上下文。前端只需按下面顺序调用接口即可实现**连续对话**。

---

## 一、整体流程（每轮对话）

```
┌─────────────────────────────────────────────────────────────────────────┐
│  前端                                                                     │
│  1. 创建会话（仅首次）或从列表选会话 → 得到 conversationId                    │
│  2. 用户输入一条消息 → POST /conversations/{id}/messages → 得到 messageId、streamUrl │
│  3. 用 streamUrl 建 SSE 连接 → GET .../stream → 收 meta / delta / done   │
│  4. 展示 AI 回复后，可继续输入下一条 → 回到步骤 2（同一 conversationId）      │
└─────────────────────────────────────────────────────────────────────────┘
```

要点：

- **一个会话 = 一个 conversationId**，多轮对话都在这个会话里进行。
- **每轮** = 一次「发一条用户消息 + 拉一次流式回复」；下一轮继续用**同一个 conversationId**，再发新消息、再拉流。
- 后端会按 `conversationId` 加载该会话的**历史消息**（见下），所以 AI 回答会带上下文，实现多轮对话。

---

## 二、接口调用顺序（前端编排）

### 1. 首次进入 / 开始新对话

| 步骤 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 1 | POST | `/api/v0/conversations` | 创建会话。请求头 `X-Client-Id` 必填；body 可选 `{"title":"..."}`。返回 201， body 含 `id`（即 **conversationId**）、`title`、`createdAt`、`updatedAt`。 |

若产品是「从会话列表选一个已有会话继续聊」，可跳过创建，直接使用已有的 `conversationId`（例如来自 `GET /api/v0/conversations` 列表）。

### 2. 每一轮：用户发一条消息并收流式回复

| 步骤 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 2a | POST | `/api/v0/conversations/{conversationId}/messages` | 提交**当前轮**的用户消息。请求头 `X-Client-Id` 必填；body 含 `content`（必填）、可选 `difficulty`、`language`、`clientMessageId`。返回 202，body 含 `messageId`、`streamUrl`、`status: "queued"`。 |
| 2b | GET | `streamUrl`（即 `/api/v0/conversations/{conversationId}/messages/{messageId}/stream`） | 用 **EventSource** 或 **fetch + ReadableStream** 打开 SSE。请求头带 `X-Client-Id`。顺序收到 `meta` → 多条 `delta` → `done`（或 `error`）。前端把每条 `delta` 的 `data.text` 拼起来即本轮 AI 回复。 |

下一轮继续用**同一个 conversationId**，再调用 2a → 2b，即可实现「不断对话」。

### 3. 可选：拉会话列表、会话详情与历史消息

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v0/conversations` | 列表当前 client 的会话（query：`limit`、`cursor`）。用于「会话列表」页。 |
| GET | `/api/v0/conversations/{conversationId}` | 会话详情 + 最近消息（query：`limit`、`before`）。用于进入某会话时展示历史。 |

---

## 三、后端如何支持「多轮」与「上下文」

- **会话与消息归属**  
  - 每条消息都挂在某个 `conversationId` 下；同一会话内的多条消息按 `created_at` 组成时间线。
- **流式接口里的历史加载**  
  - 每次处理 `GET .../stream` 时，会用当前请求的 `conversationId` 从 DB 拉取**该会话、当前用户消息之前**的若干条历史（例如最近 16 条），注入到对话记忆（ChatMemory）中。
- **调用 LLM 时**  
  - 请求中除了「当前这一条用户消息」，还会带上上述历史（user/assistant 交替），因此模型能看到上下文，实现多轮对话。
- **落库**  
  - 用户消息在 POST messages 时已落库；assistant 回复在流式结束时写入 DB（更新占位消息内容与状态），下一轮加载历史时会包含这一条。

因此：**只要前端始终用同一个 conversationId 连续调用「POST 消息 → GET stream」，后端就会自动按会话维护上下文并实现不断对话。**

---

## 四、前端最小流程示例（伪代码）

```text
// 1. 固定一个 clientId（如 UUID），存 localStorage，每次请求带 X-Client-Id
const clientId = getOrCreateClientId();

// 2. 创建或选择会话
let conversationId = await createConversation(clientId);  // 或从列表选已有 id

// 3. 循环：每一轮用户发一条、收一条流式回复
while (用户继续对话) {
  const userInput = 用户输入;
  const { messageId, streamUrl } = await postMessage(conversationId, userInput, clientId);
  const fullReply = await consumeSSE(streamUrl, clientId);  // 拼 delta 得到完整回复
  展示(fullReply);
  // 下一轮仍用同一个 conversationId，继续循环
}
```

---

## 五、小结

| 需求 | 实现方式 |
|------|----------|
| 支持多轮对话 | 同一 `conversationId` 下多次「POST 一条消息 → GET 该 message 的 stream」 |
| AI 带历史上下文 | 后端在流式接口内按 `conversationId` 加载历史并注入 LLM，无需前端传历史 |
| 对话持久化 | 用户消息、AI 回复均落库；可通过 GET 会话详情拉历史消息 |
| 多会话 | 用 GET/POST conversations 管理多个 conversationId；每个会话内独立多轮 |

按上述顺序编排接口即可实现「最终产品支持对话、不断对话」的体验；无需改后端接口契约，只需前端按同一会话、逐轮调用即可。
